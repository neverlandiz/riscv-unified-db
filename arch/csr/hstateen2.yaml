# yaml-language-server: $schema=../../schemas/csr_schema.json

$schema: "csr_schema.json#"
kind: csr
name: hstateen2
long_name: Hypervisor State Enable 2 Register
address: 0x60E
priv_mode: S
length: MXLEN
description: |
  Each bit of a `stateen` CSR controls less-privileged access to an extension’s state, for an extension that was not
  deemed "worthy" of a full XS field in `sstatus` like the FS and VS fields for the F and V extensions.

  The `stateen` registers at each level control access to state at all less-privileged levels, but not at its own level.
  This is analogous to how the existing `counteren` CSRs control access to performance counter registers. Just as with
  the `counteren` CSRs, when a `stateen` CSR prevents access to state by less-privileged levels, an attempt in one of those
  privilege modes to execute an instruction that would read or write the protected state raises an illegal instruction
  exception, or, if executing in VS or VU mode and the circumstances for a virtual instruction exception apply, raises
  a virtual instruction exception instead of an illegal instruction exception.

  When this extension is not implemented, all state added by an extension is accessible as defined by that extension.

  When a `stateen` CSR prevents access to state for a privilege mode, attempting to execute in that privilege mode an
  instruction that implicitly updates the state without reading it may or may not raise an illegal instruction or
  virtual instruction exception. Such cases must be disambiguated by being explicitly specified one way or the other.

  In some cases, the bits of the `stateen` CSRs will have a dual purpose as enables for the ISA extensions that
  introduce the controlled state.

  With the hypervisor extension, the `hstateen` CSRs have identical encodings to the `mstateen` CSRs, except controlling
  accesses for a virtual machine (from VS and VU modes).

  Each standard-defined bit of a `stateen` CSR is WARL and may be read-only zero or one, subject to the following conditions.

  Bits in any `stateen` CSR that are defined to control state that a hart doesn’t implement are read-only zeros for that
  hart. Likewise, all reserved bits not yet given a defined meaning are also read-only zeros. For every bit in an `mstateen`
  CSR that is zero (whether read-only zero or set to zero), the same bit appears as read-only zero in the matching `hstateen`
  and `sstateen` CSRs. For every bit in an `hstateen` CSR that is zero (whether read-only zero or set to zero), the same bit
  appears as read-only zero in `sstateen` when accessed in VS-mode.

  A bit in a supervisor-level `sstateen` CSR cannot be read-only one unless the same bit is read-only one in the matching
  `mstateen` CSR and, if it exists, in the matching `hstateen` CSR. A bit in an `hstateen` CSR cannot be read-only one unless
  the same bit is read-only one in the matching `mstateen` CSR.

  On reset, all writable `mstateen` bits are initialized by the hardware to zeros. If machine-level software changes these
  values, it is responsible for initializing the corresponding writable bits of the `hstateen` and `sstateen` CSRs to zeros
  too. Software at each privilege level should set its respective `stateen` CSRs to indicate the state it is prepared to
  allow less-privileged software to access. For OSes and hypervisors, this usually means the state that the OS or hypervisor
  is prepared to swap on a context switch, or to manage in some other way.

  For each `mstateen` CSR, bit 63 is defined to control access to the matching `sstateen` and `hstateen` CSRs. That is, bit 63
  of `mstateen0` controls access to `sstateen0` and `hstateen0`; bit 63 of `mstateen1` controls access to `sstateen1` and `hstateen1`;
  etc. Likewise, bit 63 of each `hstateen` correspondingly controls access to the matching `sstateen` CSR.

  A hypervisor may need this control over accesses to the `sstateen` CSRs if it ever must emulate for a virtual machine
  an extension that is supposed to be affected by a bit in an `sstateen` CSR. Even if such emulation is uncommon, it should not be excluded.

  Machine-level software needs identical control to be able to emulate the hypervisor extension. That is, machine level needs control over
  accesses to the supervisor-level `sstateen` CSRs in order to emulate the `hstateen` CSRs, which have such control.

definedBy:
  allOf:
    - H
    - Smstateen
    - Ssstateen
fields:
  SE0:
    location: 63
    base: 64
    description: |
      The SE0 bit in `hstateen2` controls access to the `sstateen2` CSR.
    type: RW
    reset_value: UNDEFINED_LEGAL
