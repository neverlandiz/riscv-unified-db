# yaml-language-server: $schema=../../schemas/csr_schema.json

$schema: "csr_schema.json#"
kind: csr
name: hstateen0
long_name: Hypervisor State Enable 0 Register
address: 0x60C
priv_mode: S
length: MXLEN
description: |
  Each bit of a `stateen` CSR controls less-privileged access to an extension’s state,
  for an extension that was not deemed "worthy" of a full XS field in `sstatus` like the
  FS and VS fields for the F and V extensions. The number of registers provided at each
  level is four because it is believed that 4 * 64 = 256 bits for machine and hypervisor
  levels, and 4 * 32 = 128 bits for supervisor level, will be adequate for many years to
  come, perhaps for as long as the RISC-V ISA is in use. The exact number four is an
  attempted compromise between providing too few bits on the one hand and going overboard
  with CSRs that will never be used on the other.

  The `stateen` registers at each level control access to state at all less-privileged levels,
  but not at its own level.

  When a `stateen` CSR prevents access to state for a privilege mode, attempting to execute in
  that privilege mode an instruction that implicitly updates the state without reading it may
  or may not raise an illegal instruction or virtual instruction exception. Such cases must
  be disambiguated by being explicitly specified one way or the other.
  In some cases, the bits of the `stateen` CSRs will have a dual purpose as enables for the ISA
  extensions that introduce the controlled state.

  For each `hstateen` CSR, bit 63 is defined to control access to the matching `sstateen` CSR.
  Bit 63 of `hstateen0` controls access to `sstateen0`.

  With the hypervisor extension, the `hstateen` CSRs have identical encodings to the `mstateen`
  CSRs, except controlling accesses for a virtual machine (from VS and VU modes).

  For every bit in an `hstateen` CSR that is zero (whether read-only zero or set to zero),
  the same bit appears as read-only zero in `sstateen` when accessed in VS-mode.

  A bit in an `hstateen` CSR cannot be read-only one unless the same bit is read-only one
  in the matching `mstateen` CSR.

definedBy:
  allOf:
    - H
    - Smstateen
    - Ssstateen
fields:
  SE0:
    location: 63
    base: 64
    description: |
      The SE0 bit in `hstateen0` controls access to the `sstateen0` CSR.
    type: RW
    reset_value: UNDEFINED_LEGAL
  ENVCFG:
    location: 62
    base: 64
    description: |
      The ENVCFG bit in `hstateen0` controls access to the `senvcfg` CSRs.
    type: RW
    reset_value: UNDEFINED_LEGAL
  CSRIND:
    location: 60
    base: 64
    description: |
      The CSRIND bit in `hstateen0` controls access to the `siselect` and the
      `sireg*`, (really `vsiselect` and `vsireg*`) CSRs provided by the Sscsrind
      extensions.
    type: RW
    reset_value: UNDEFINED_LEGAL
  AIA:
    location: 59
    base: 64
    description: |
      The AIA bit in `hstateen0` controls access to all state introduced by
      the Ssaia extension and is not controlled by either the CSRIND or the
      IMSIC bits of `hstateen0`.
    type: RW
    reset_value: UNDEFINED_LEGAL
  IMSIC:
    location: 58
    base: 64
    description: |
      The IMSIC bit in `hstateen0` controls access to the guest IMSIC state,
      including CSRs `stopei` (really `vstopei`), provided by the Ssaia extension.

      Setting the IMSIC bit in `hstateen0` to zero prevents a virtual machine
      from accessing the hart’s IMSIC the same as setting `hstatus.`VGEIN = 0.
    type: RW
    reset_value: UNDEFINED_LEGAL
  CONTEXT:
    location: 57
    base: 64
    description: |
      The CONTEXT bit in `hstateen0` controls access to the `scontext` CSR provided
      by the Sdtrig extension.
    type: RW
    reset_value: UNDEFINED_LEGAL
  JVT:
    location: 2
    description: |
      The JVT bit controls access to the `jvt` CSR provided by the Zcmt extension.
    type: RW
    reset_value: UNDEFINED_LEGAL
  FCSR:
    location: 1
    description: |
      The FCSR bit controls access to `fcsr` for the case when floating-point instructions
      operate on `x` registers instead of `f` registers as specified by the Zfinx and related
      extensions (Zdinx, etc.). Whenever `misa.F` = 1, FCSR bit of `mstateen0` is read-only
      zero (and hence read-only zero in `hstateen0` and `sstateen0` too). For convenience,
      when the `stateen` CSRs are implemented and `misa.F` = 0, then if the FCSR bit of a
      controlling `stateen0` CSR is zero, all floating-point instructions cause an illegal
      instruction trap (or virtual instruction trap, if relevant), as though they all access
      `fcsr`, regardless of whether they really do.
    type: RW
    reset_value: UNDEFINED_LEGAL
  C:
    location: 0
    description: |
      The C bit controls access to any and all custom state. This bit is not custom state itself.
      The C bit of these registers is not custom state itself; it is a standard field of a
      standard CSR, either `mstateen0`, `hstateen0`, or `sstateen0`.
    type: RW
    reset_value: UNDEFINED_LEGAL
