# yaml-language-server: $schema=../../schemas/csr_schema.json

$schema: "csr_schema.json#"
kind: csr
name: mstateen0
long_name: Machine State Enable 0 Register
address: 0x30C
priv_mode: M
length: MXLEN
description: |
  Each bit of a `stateen` CSR controls less-privileged access to an extension’s state, for an extension that was not
  deemed "worthy" of a full XS field in `sstatus` like the FS and VS fields for the F and V extensions.

  The `stateen` registers at each level control access to state at all less-privileged levels, but not at its own level.
  This is analogous to how the existing `counteren` CSRs control access to performance counter registers. Just as with
  the `counteren` CSRs, when a `stateen` CSR prevents access to state by less-privileged levels, an attempt in one of those
  privilege modes to execute an instruction that would read or write the protected state raises an illegal instruction
  exception, or, if executing in VS or VU mode and the circumstances for a virtual instruction exception apply, raises
  a virtual instruction exception instead of an illegal instruction exception.

  When this extension is not implemented, all state added by an extension is accessible as defined by that extension.

  When a `stateen` CSR prevents access to state for a privilege mode, attempting to execute in that privilege mode an
  instruction that implicitly updates the state without reading it may or may not raise an illegal instruction or
  virtual instruction exception. Such cases must be disambiguated by being explicitly specified one way or the other.

  In some cases, the bits of the `stateen` CSRs will have a dual purpose as enables for the ISA extensions that
  introduce the controlled state.

  For every bit with a defined purpose in an `sstateen` CSR, the same bit is defined in the matching
  `mstateen` CSR to control access below machine level to the same state. The upper 32 bits of an
  `mstateen` CSR (or for RV32, the corresponding high-half CSR) control access to state that is inherently
  inaccessible to user level, so no corresponding enable bits in the supervisor-level `sstateen` CSR are
  applicable. The intention is to allocate bits for this purpose starting at the most-significant end, bit 63,
  through to bit 32, and then on to the next-higher `mstateen` CSR. If the rate that bits are being allocated
  from the least-significant end for `sstateen` CSRs is sufficiently low, allocation from the most-significant
  end of `mstateen` CSRs may be allowed to encroach on the lower 32 bits before jumping to the next-higher
  `mstateen` CSR. In that case, the bit positions of "encroaching" bits will remain forever read-only zeros in
  the matching `sstateen` CSRs.

  Each standard-defined bit of a `stateen` CSR is WARL and may be read-only zero or one, subject to the following conditions.

  Bits in any `stateen` CSR that are defined to control state that a hart doesn’t implement are read-only zeros for that
  hart. Likewise, all reserved bits not yet given a defined meaning are also read-only zeros. For every bit in an `mstateen`
  CSR that is zero (whether read-only zero or set to zero), the same bit appears as read-only zero in the matching `hstateen`
  and `sstateen` CSRs. For every bit in an `hstateen` CSR that is zero (whether read-only zero or set to zero), the same bit
  appears as read-only zero in `sstateen` when accessed in VS-mode.

  A bit in a supervisor-level `sstateen` CSR cannot be read-only one unless the same bit is read-only one in the matching
  `mstateen` CSR and, if it exists, in the matching `hstateen` CSR. A bit in an `hstateen` CSR cannot be read-only one unless
  the same bit is read-only one in the matching `mstateen` CSR.

  On reset, all writable `mstateen` bits are initialized by the hardware to zeros. If machine-level software changes these
  values, it is responsible for initializing the corresponding writable bits of the `hstateen` and `sstateen` CSRs to zeros
  too. Software at each privilege level should set its respective `stateen` CSRs to indicate the state it is prepared to
  allow less-privileged software to access. For OSes and hypervisors, this usually means the state that the OS or hypervisor
  is prepared to swap on a context switch, or to manage in some other way.

  For each `mstateen` CSR, bit 63 is defined to control access to the matching `sstateen` and `hstateen` CSRs. That is, bit 63
  of `mstateen0` controls access to `sstateen0` and `hstateen0`; bit 63 of `mstateen1` controls access to `sstateen1` and `hstateen1`;
  etc. Likewise, bit 63 of each `hstateen` correspondingly controls access to the matching `sstateen` CSR.

  Bit 63 of each `mstateen` CSR may be read-only zero only if the hypervisor extension is not implemented and the matching
  supervisor-level `sstateen` CSR is all read-only zeros. In that case, machine-level software should emulate attempts to access
  the affected `sstateen` CSR from S-mode, ignoring writes and returning zero for reads. Bit 63 of each `hstateen` CSR is always
  writable (not read-only).

definedBy: Smstateen
fields:
  SE0:
    long_name: hstateen0, hstateen0h, and sstateen0 access control
    location: 63
    base: 64
    description: |
      The SE0 bit in `mstateen0` controls access to the `hstateen0`, `hstateen0h`, and the `sstateen0` CSRs.
    type: RW
    reset_value: UNDEFINED_LEGAL
  ENVCFG:
    long_name: henvcfg, henvcfgh, and senvcfg access control
    location: 62
    definedBy:
      name: S
      version: ">= 1.11"
    base: 64
    description: |
      The ENVCFG bit in `mstateen0` controls access to the `henvcfg`, `henvcfgh`, and the `senvcfg` CSRs.
    type: RW
    reset_value: UNDEFINED_LEGAL
  CSRIND:
    long_name: siselect, sireg*, vsiselect, and vsireg* access control
    location: 60
    definedBy: Sscsrind
    base: 64
    description: |
      The CSRIND bit in `mstateen0` controls access to the `siselect`, `sireg*`, `vsiselect`, and the `vsireg*`
      CSRs provided by the Sscsrind extensions.
    type: RW
    reset_value: UNDEFINED_LEGAL
  AIA:
    long_name: Ssaia state access control
    location: 59
    definedBy: Ssaia
    base: 64
    description: |
      The AIA bit in `mstateen0` controls access to all state introduced by the Ssaia extension and is not
      controlled by either the CSRIND or the IMSIC bits.
    type: RW
    reset_value: UNDEFINED_LEGAL
  IMSIC:
    long_name: IMSIC state access control
    location: 58
    definedBy: Ssaia
    base: 64
    description: |
      The IMSIC bit in `mstateen0` controls access to the IMSIC state, including CSRs `stopei` and `vstopei`,
      provided by the Ssaia extension.
    type: RW
    reset_value: UNDEFINED_LEGAL
  CONTEXT:
    long_name: scontext and hcontext access control
    location: 57
    definedBy: Sdtrig
    base: 64
    description: |
      The CONTEXT bit in `mstateen0` controls access to the `scontext` and `hcontext` CSRs provided by the
      Sdtrig extension.
    type: RW
    reset_value: UNDEFINED_LEGAL
  P1P13:
    long_name: hedelegh access control
    location: 56
    base: 64
    description: |
      The P1P13 bit in `mstateen0` controls access to the `hedelegh` introduced by Privileged Specification
      Version 1.13.
    type: RW
    reset_value: UNDEFINED_LEGAL
  JVT:
    long_name: jvt access control
    location: 2
    definedBy: Zcmt
    description: |
      The JVT bit controls access to the `jvt` CSR provided by the Zcmt extension.
    type: RW
    reset_value: UNDEFINED_LEGAL
  FCSR:
    long_name: fcsr access control
    location: 1
    definedBy:
      anyOf: [Zfinx, Zdinx]
    description: |
      The FCSR bit controls access to `fcsr` for the case when floating-point instructions
      operate on `x` registers instead of `f` registers as specified by the Zfinx and related
      extensions (Zdinx, etc.). Whenever `misa.F` = 1, FCSR bit of `mstateen0` is read-only
      zero (and hence read-only zero in `hstateen0` and `sstateen0` too). For convenience,
      when the `stateen` CSRs are implemented and `misa.F` = 0, then if the FCSR bit of a
      controlling `stateen0` CSR is zero, all floating-point instructions cause an illegal
      instruction trap (or virtual instruction trap, if relevant), as though they all access
      `fcsr`, regardless of whether they really do.
    type: RW
    reset_value: UNDEFINED_LEGAL
  C:
    long_name: custom state access control
    location: 0
    description: |
      The C bit controls access to any and all custom state. This bit is not custom state itself. The C bit of
      these registers is not custom state itself; it is a standard field of a standard CSR, either `mstateen0`,
      `hstateen0`, or `sstateen0`.
    type: RW
    reset_value: UNDEFINED_LEGAL
