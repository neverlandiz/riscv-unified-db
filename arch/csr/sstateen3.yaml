# yaml-language-server: $schema=../../schemas/csr_schema.json

$schema: "csr_schema.json#"
kind: csr
name: sstateen3
long_name: Supervisor State Enable 3 Register
address: 0x10F
priv_mode: S
length: MXLEN
description: |
  Each bit of a `stateen` CSR controls less-privileged access to an extension’s state, for an extension that was not
  deemed "worthy" of a full XS field in `sstatus` like the FS and VS fields for the F and V extensions.

  The `stateen` registers at each level control access to state at all less-privileged levels, but not at its own level.
  This is analogous to how the existing `counteren` CSRs control access to performance counter registers. Just as with
  the `counteren` CSRs, when a `stateen` CSR prevents access to state by less-privileged levels, an attempt in one of those
  privilege modes to execute an instruction that would read or write the protected state raises an illegal instruction
  exception, or, if executing in VS or VU mode and the circumstances for a virtual instruction exception apply, raises
  a virtual instruction exception instead of an illegal instruction exception.

  When this extension is not implemented, all state added by an extension is accessible as defined by that extension.

  When a `stateen` CSR prevents access to state for a privilege mode, attempting to execute in that privilege mode an
  instruction that implicitly updates the state without reading it may or may not raise an illegal instruction or
  virtual instruction exception. Such cases must be disambiguated by being explicitly specified one way or the other.

  In some cases, the bits of the `stateen` CSRs will have a dual purpose as enables for the ISA extensions that
  introduce the controlled state.

  For every bit with a defined purpose in an `sstateen` CSR, the same bit is defined in the matching
  `mstateen` CSR to control access below machine level to the same state. The upper 32 bits of an
  `mstateen` CSR (or for RV32, the corresponding high-half CSR) control access to state that is inherently
  inaccessible to user level, so no corresponding enable bits in the supervisor-level `sstateen` CSR are
  applicable. The intention is to allocate bits for this purpose starting at the most-significant end, bit 63,
  through to bit 32, and then on to the next-higher `mstateen` CSR. If the rate that bits are being allocated
  from the least-significant end for `sstateen` CSRs is sufficiently low, allocation from the most-significant
  end of `mstateen` CSRs may be allowed to encroach on the lower 32 bits before jumping to the next-higher
  `mstateen` CSR. In that case, the bit positions of "encroaching" bits will remain forever read-only zeros in
  the matching `sstateen` CSRs.

  Each standard-defined bit of a `stateen` CSR is WARL and may be read-only zero or one, subject to the following conditions.

  Bits in any `stateen` CSR that are defined to control state that a hart doesn’t implement are read-only zeros for that
  hart. Likewise, all reserved bits not yet given a defined meaning are also read-only zeros. For every bit in an `mstateen`
  CSR that is zero (whether read-only zero or set to zero), the same bit appears as read-only zero in the matching `hstateen`
  and `sstateen` CSRs. For every bit in an `hstateen` CSR that is zero (whether read-only zero or set to zero), the same bit
  appears as read-only zero in `sstateen` when accessed in VS-mode.

  A bit in a supervisor-level `sstateen` CSR cannot be read-only one unless the same bit is read-only one in the matching
  `mstateen` CSR and, if it exists, in the matching `hstateen` CSR. A bit in an `hstateen` CSR cannot be read-only one unless
  the same bit is read-only one in the matching `mstateen` CSR.

  On reset, all writable `mstateen` bits are initialized by the hardware to zeros. If machine-level software changes these
  values, it is responsible for initializing the corresponding writable bits of the `hstateen` and `sstateen` CSRs to zeros
  too. Software at each privilege level should set its respective `stateen` CSRs to indicate the state it is prepared to
  allow less-privileged software to access. For OSes and hypervisors, this usually means the state that the OS or hypervisor
  is prepared to swap on a context switch, or to manage in some other way.

  For each `mstateen` CSR, bit 63 is defined to control access to the matching `sstateen` and `hstateen` CSRs. That is, bit 63
  of `mstateen0` controls access to `sstateen0` and `hstateen0`; bit 63 of `mstateen1` controls access to `sstateen1` and `hstateen1`;
  etc. Likewise, bit 63 of each `hstateen` correspondingly controls access to the matching `sstateen` CSR.

  A hypervisor may need this control over accesses to the `sstateen` CSRs if it ever must emulate for a virtual machine
  an extension that is supposed to be affected by a bit in an `sstateen` CSR. Even if such emulation is uncommon, it should not be excluded.

  Machine-level software needs identical control to be able to emulate the hypervisor extension. That is, machine level needs control over
  accesses to the supervisor-level `sstateen` CSRs in order to emulate the `hstateen` CSRs, which have such control.

  Bit 63 of each `mstateen` CSR may be read-only zero only if the hypervisor extension is not implemented and the matching
  supervisor-level `sstateen` CSR is all read-only zeros. In that case, machine-level software should emulate attempts to access
  the affected `sstateen` CSR from S-mode, ignoring writes and returning zero for reads. Bit 63 of each `hstateen` CSR is always
  writable (not read-only).

definedBy:
  allOf:
    - Smstateen
    - Ssstateen

fields:
  DATA:
    location_rv64: 63-0
    location_rv32: 31-0
    description: Data value
    type: RW
    reset_value: UNDEFINED_LEGAL
